\subsection{Implementación}
\subsubsection{Ejercicio 1: }

Este ejercicio consiste en armar la GDT, preparar el kernel para saltar a modo protegido e imprimir
cosas en pantalla.
La primera entrada de la GDT es una entrada nula, luego, cargamos los descriptores correspondientes a cada nivel (0 y 3) para código y datos respectivamente. Notar que la diferencia entre cada par
de segmentos en el mismo nivel es únicamente el campo tipo. Por ejemplo, un descriptor de segmento
de código de nivel 0 es de la forma:
\begin{itemize}
	\item \textbf{límite} = \texttt{0x001F3FF}, es decir, completamos los campos limit(0:15) con \texttt{0xF3FF} y limit(16:19) con \texttt{0x1} y activamos granularidad para que direccione a 500 MB, es decir, que extienda el límite ingresado.
	\item \textbf{base} = \texttt{0x00000000}, es decir, completamos los campos base(0:15) con \texttt{0x0000}, base(23:16) con
\texttt{0x00} y base(31:24) con \texttt{0x00}.
	\item En el tipo le pusimos 0xA para indicar que es de código y permitir que se pueda leer y ejecutar.
	\item En el bit de sistema le pusimos 1 para indicar que no es de sistema.
	\item Le asignamos privilegio de kernel (DPL = 0).
	\item Lo marcamos como presente.
	\item En el campo AVL pusimos 0 al igual que en el campo \textit{l} pues trabajamos con la arquitectura de 32 bits y como trabajamos con segmentos de 32 bits marcamos el bit DB como uno.
\end{itemize}
Para definir el segmento de datos nivel 0 la inizialización es muy similar, solo difiere en el campo tipo, donde vez de ser \textbf{0xA} es \textbf{0x2}:
Para definir el segmento de código nivel 3 la inicialización tambien es muy parecida, excepto por el
campo DPL, que ahora es \textbf{0x3} (pues es otro nivel de privilegio) en vez de \textbf{0x0}.
El resto de las definiciones es análoga. \\
Una vez hecho esto, debíamos preparar todo lo necesario para pasar a modo protegido y setear la pila del kernel en la posición \textbf{0x27000}.
Para pasar a modo protegido, lo que realizamos fue:
\begin{itemize}
	\item Deshabilitar las interrupciones, usando \textbf{cli}.
	\item Habilitamos A20 (llamando a la rutina habilitar\_ A20).
	\item Cargamos la GDT utilizando la instrucción \texttt{lgdt[GDT\_ DESC]}, donde GDT\_DESC es la base de la GDT.
	\item Seteamos el bit PE del registro CR0 realizando un OR entre lo que contiene este registro y \textbf{0x1}
	\item Finalmente realizamos el salto a \textbf{(0x8*8):modo\_rotegido}, pues en la posición \textbf{0x8} de la GDT se encuentra el selector de código de nivel 0 y \textbf{modo\_protegido} es la etiqueta donde empezamos a definir el código correspondiente al modo protegido.
\end{itemize}
Estando en modo protegido, seteamos los correspondientes registros de segmento de datos y el segmento
extra para video (en \texttt{fs}). Además para setear la pila en la dirección \textbf{0x27000}, una vez en modo protegido, cargamos los registros \texttt{ebp} y \texttt{esp} con el valor \textbf{0x27000}.
Finalmente, para terminar el ejercicio, inicializamos la pantalla llamando a la función proporcionada por la cátedra \texttt{screen\_inicializar()} la cual pinta el área de la pantalla con los colores que se muestran en el enunciado.


\subsubsection{Ejercicio 2}
\indent Completamos las entradas de la IDT para las entradas 0-19 (20 a 31 estan reservadas), y las correspondientes para el ejercicio 5 (32 : reloj, 33 teclado y 0x46 para la syscall) .\\
\indent Todas estas entradas fueron inicializadas con los siguientes valores:
\begin{itemize}
 \item En el campo offset(15:0) se colocan los últimos 2 bytes de la dirección donde se encuentra la rutina de atención de la interrupción en cuestión.
 \item En el selector de segmento ponemos 0x0008, que corresponde a un segmento de código de nivel 0.
 \item En los atributos de la entrada IDT usuario colocamos 0xEE00 (macro ID\_ENTRY2) que indica que estamos trabajando con una interrupt gate, de tamaño 32 bits, DPL 3 y presente.
 \item En los atributos de la entrada IDT supervisor colocamos 0x8E00 (macro ID\_ENTRY2 que indica que estamos trabajando con una interrupt gate, de tamaño 32 bits, dpl 0 y presente.
 \item En el campo offset(32:16) colocamos los primero 2 bytes de la dirección donde se encuentra la rutina de atención de la interrupción en cuestión.
\end{itemize}

\indent Luego, completamos en el archivo isr.asm, los headers de las rutinas de atención para todas estas entradas de IDT. Para cada uno, imprimimos en pantalla a qué interrupción se está llamando utilizando la macro ISR.\\

\indent Una vez realizado todo esto, para probar el uso de estas rutinas por parte del procesador,  realizamos una división por cero, y efectivamente, se nos imprime en pantalla el mensaje de ``Divide Error''.


\subsubsection{Ejercicio 3}
\indent La inicializaci\'on del directorio y la tabla de p\'aginas la completamos sin hacer uso de la funci\'on inicializar\_dir\_kernel sino que lo hamos directamente en kernel.asm de la siguiente forma:
\begin{itemize}
\item Inicializamos todas las posiciones del Page Directory (PD) en 0x00000002.
\item Apuntamos la primer página de PD a la page table y seteamos los bits de presente y lectura/escritura
\item Realizamos el identity mapping (vinculamos la posición 0 con la dirección de memoria 0x0000) para las 164 cada p\'aginas de la PAGE TABLE y activamos la lectura/escritura y el bit de presencia de cada página.
\end{itemize}

\indent Vale destacar que para cumplir con lo que pide el enunciado con respecto a donde inicializar las tablas, esto lo cumplimos al utilizar como posición inicial del Page Directory a la 0x27000 y a la del Page Table 0x28000	usando las constantes KERNEL\_PAGE\_DIR y KERNEL\_PAGE\_TABLE en defines.h\\

\indent Para activar paginación, lo que realizamos fue cargar en el camó base del cr3 la dirección del PD y setear el bit de paginación (or usando 0x80000000) del cr0.\\

\indent Testeamos el ejercicio desmapeando la \'ultima p\'agina 0x3FF000.\\


\subsubsection{Ejercicio 4}

a) Escribir una rutina (inicializar_mmu) que se encargue de inicializar las estructuras glo-
bales necesarias para administrar la memoria en el area libre (un contador de paginas
libres).
\indent Para completar la rutina que inicializa la mmu, lo \'unico que hicimos fue definir y setear: \\

\begin{itemize}
\item PRIMER_PAG_LIBR: 0x101000
\item ULTIMA_PAG_LIBR: 0x3fe000
\end{itemize}

Adem\'as de implementar las funciones necesarias para el mapeo de las p\'aginas:\\ 

\begin{itemize}
\itemu int mmu_proxima_pagina_fisica_libre()
\item void mmu_mapear_areas_de_kernel_y_libre(unsigned int cr3)
\item void mmu_mapear_pagina (uint virtual, uint cr3, uint fisica, uint attrs)
\end{itemize}

Esto fue necesario para escribir la rutina $mmu_inicializar_memoria_perro$ encargada de inicializar un directorio de paginas y una tabla de paginas para cada una de las tareas (perros). \\

Con todo implementado inicializamos la tarea de un perro y la intercambiamos con el kernel, luego cambiamos de el color del fondo del primer caracter. Para luego volver a la normalidad, con esto nos aseguramos el correcto funcionamiento de lo reci\'en implmentado. \\


\subsubsection{Ejercicio 5}

\indent En el punto 3 hab\'iamos agregado las 3 entradas extras en la IDT : 
\begin{itemize}
\itemu 32 para reloj
\item 33 para teclado
\item 0x46 para syscall
\end{itemize}

Las primeras 2 entradas las completamos de la misma forma que hicimos con las interrupciones del procesador en el punto 3. Es decir, para completar la entrada de IDT pusimos como offset el campo offset(15:0) la direcci\'on donde se encuentra la rutina de atenci\'on de la interrupci\'on en cuesti\'on, en el selector de segmento ponemos 0x08 (que corresponde a un segmento de c\'odigo de nivel 0) y en los atributos colocamos 0x8E00 (que indica que estamos trabajando con una interrupt gate, de tamaño 32 bits, dpl 0 y presente). 
La entrada de IDT correspondiente a la interrupcion 0x46, la completamos exactamente de la misma forma, pero poniendo el dpl en 3 (o sea attrs en 0xEE00), pues es una interrupcion de tareas.\\

%b) Escribir la rutina asociada a la interrupci ́n del reloj, para que por cada tick llame a la funci ́n proximo reloj. La misma se encarga de mostrar, por cada vez que se llama, la animaci ́n de un cursor rotando. En la figura 6 se detalla en que posici ́n de la pantalla aparece el reloj. La funci ́n proximo reloj est ́ definida en isr.asm.

\indent Para completar la rutina del reloj, completamos en el archivo isr.asm la entrada \_isr32 de la siguiente forma: primero desactivamos interrupciones, preservamos registros y EFLAGS,  llamamos a fin\_intr\_pic1 y luego llamamos a la rutina de pr\'oximo\_reloj. Una vez hecho esto, restauramos el valor del registro EFLAGS y de los otros, activamos interrupciones y hacemos iret. Más adelante, tuvimos que modificar esta rutina para agregar atributos y funciones del scheduler.\\

En el caso de la rutina de teclado, realizamos lo siguiente:
\begin{enumerate}
	\item desactivamos interrupciones
	\item preservamos registros y EFLAGS
	\item llamamos a fin\_intr\_pic1
	\item movemos al registro del inout el valor 0x60
	\item invocamos game_atender_teclado
	\item restauramos EFLAGS y registros
	\item activamos interrupciones
	\item iret
\end{enumerate}

La funci\'on game_atender_teclado es la que se encarga de realizar alguna acci\'on segun la tecla que fue presionada.\\

Para la rutina de la \_isr46 va a ser terminada de implmentar en los ejercicios siguientes.\\

------
\subsubsection{Ejercicio 6}
\indent Como primer paso, definimos las entradas para la tarea inicial e idle en la gdt dejando algunos valores para completar desde tss.c (pu\'es valores din\'amicos no pueden estar en la inicializaci\'on). Ellon son :\\
\begin{itemize}
	\item base\_0\_15
	\item base\_23\_16
	\item base\_31\_24
	\item limit\_0\_15
\end{itemize}
La raz\'on por la cual se pospone la inicializaci\'on de esos valores es porque primero necesitamos inicializada la tabla ``tsss'', la cual se hace durante el llamado a la funci\'on ``tss\_inicializar''.\\

\indent Para inicializar la TSS de la tarea IDLE, realizamos una función (tss\_initializar\_tarea\_idle) que mapea a dirección virtual del código de la tarea con la dirección física del código y completa la TSS con los siguientes valores:
\begin{itemize}
	\item En donde se almacena el CR3 se guarda el del kernel;
	\item Se ubica la direcci\'on del eip en donde se encuentra el c\'odigo de la tarea;
	\item Se setean los EFLAGS en 0x202, es decir con interrupciones en 1 y presente;
	\item Como la tarea IDLE corre en nivel 0, se mantienen los registros de segmentación del kernel;
	\item Se apuntan el esp0, el esp y el ebp a donde se aloja la pila de la tarea IDLE
\end{itemize}


\indent La función tss\_inicializar\_tarea tiene como fin completar la TSS de una tarea en particular, la que se pasa por parámetro y lo hace de la siguiente manera:\\
\begin{itemize}
	\item Guarda como cr3 la dirección del directorio de páginas de la tarea;
	\item Se sitúa la dirección del eip a donde se encuentra la tarea;
	\item EFLAGS nuevamente en 0x202;
	\item Como las tareas corren en nivel 3 y para cumplir con lo pedido, se almacenan los siguientes valores para los registros de segmentación:
		\begin{itemize}
		\item es = ss = ds = fs = gs = 0x33, que es un segmento de datos de nivel 3;
		\item cs = 0x2B, que es un segmento de código de nivel 3;
		\end{itemize}
	\item Tanto esp como ebp se ubican en la dirección de la pila de la tarea que es TASK\_STACK;
	\item El esp0 en  la dirección física de la pila de nivel 0 de la tarea.
	\item El ss de nivel 0 en el segmento de datos de nivel 0 ubicado en la posicipón 0x60;
\end{itemize}

\indent Para la funci\'on tss\_initializar\_tarea\_inicial no nos interesa setear valores para su respectivo tss puesto que nunca se va a saltar a esa tarea, solo nos interesa setear los valores de la GDT que no pudimos setear en la inicializaci\'on.\\

\indent Para completar los descriptores anteriormente nombrados, utilizamos una funci\'on que se llama tss\_inicializar, la cual se encarga de llamar a :\\
\begin{itemize}
	\item tss\_initializar\_tarea\_inicial
	\item tss\_initializar\_tarea\_idle
\end{itemize}

\indent Una vez hecho todo eso, para ejecutar la tarea IDLE, primero llamamos a inicializar\_scheduler, que inicializa todas las estructuras necesarias para arrancar el scheduler. Posteriormente cargamos el selector de la tarea inicial en un registro, es decir, el 0x40 y lo cargamos en el task register. Luego de cargar el task register, hacemos un cambio de tareas pasando a la tarea idle mediante un \emph{0x48:0}. La CPU correr\'a la tarea idle y cuando se produzca la pr\'oxima interrupci\'on de reloj saltar\'a a la primera tarea. \\


\subsubsection{Ejercicio 7}

\indent Implementamos la funci\'on $sched_inicializar()$ seteando:\\

Primero para la IDLE:\\
\begin{itemize}
	\item scheduler.tasks[MAX_CANT_TAREAS_VIVAS].gdt_index = COD_TAREA_IDLE_DIR
	\item scheduler.tasks[MAX_CANT_TAREAS_VIVAS].perro = NULL;
\end{itemize}

Luego para cada perro en el arreglo de tareas: \\

\begin{itemize}
	\item scheduler.tasks[i].gdt_index = (GDT_IDX_TSS_BASE_PERROS_A + i)
	\item scheduler.tasks[i].perro = NULL
	\item scheduler.tasks[MAX_CANT_PERROS_VIVOS + i].gdt_index = (GDT_IDX_TSS_BASE_PERROS_B + i);
	\item scheduler.tasks[MAX_CANT_PERROS_VIVOS + i].perro = NULL;
\end{itemize}

Y por \'ultimo los jugadores: \\

\begin{itemize}
	\item scheduler.current = 0
	\item scheduler.indice_ultimo_jugador_A = 1
	\item scheduler.indice_ultimo_jugador_B = 9
\end{itemize}


\indent Implementamos la funci\'on sched\_proximo\_indice(), cuya funcionalidad es hacer el switcheo de tareas entre los perros de cada jugador, el mecanismo es intercalar una ejecuci\'on es un perro de cada jugador a la vez, sin repetir el perro en caso de que tengan vivo mas de uno. es decir se  van turnando haciendo round-robin.

\indent Modificamos la interrupci\'on 0x46, para que implemente los servicios del sistema especificados en la secci\'on 4.4 del enunciado.


\indent  Manejamos las rutinas de excepciones para cada tarea, en caso que haya un error se procede a eliminar la tarea del scheduler.

\subsubsection{Modo Debug}



\newpage



